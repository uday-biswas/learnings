//applying practical kubernetes
-> firstly we have to create a pod using pod.yml file.
-> then apply the pod.yml file using command kubectl apply -f pod.yml
-> we can see the pod using command kubectl get pods -o wide

-> we can also create a deployment using deployment.yml file, but before that we have to delete the pod using command 'kubectl delete pod podname'
   deployment will create replica sets which will create pods.
-> then apply the deployment.yml file using command 'kubectl apply -f deployment.yml'
-> we can see the deployment using command 'kubectl get deployment'
-> we can see the replica sets using command 'kubectl get rs'
-> here if any pod is deleted then replica set will create another pod, but its ip address will be different.
   to handle this we can create a service using service.yml file.
   load balancing - the service will create a load balancer which will have a single ip address and it will be used to access the pods.
   service discovery - the pods will be accessed using the labels and selectors which are present in the service.yml file.
   expose to world - the service will expose the pods to the world.
-> create and apply the service.yml file using command kubectl apply -f service.yml
-> three types of services are there - cluster ip, node port, load balancer.
   - cluster ip - it will create a single ip address which will be used to access the pods, 
                  so , the users having the ip address can access the pods.
    - node port - it will create a port number which will be used to access the pods,
                  so, the users having ip address along with the port number can access the pods.
    - load balancer - it will create a public domain name which will be used to access the pods,
                      so, the users having the domain name can access the pods.(exposed to world)
 
 example deployment of python app
   -> create a docker file and build the image using command docker build -t udaybiswas944/python-app-demo .
   -> push the image to docker hub using command docker push udaybiswas944/python-app-demo
   -> create a deployment.yml file and apply it using command kubectl apply -f deployment.yml
   - content of deployment.yml file
      apiVersion: apps/v1
      kind: Deployment
      metadata:
      name: sample-python-app
      labels:
         app: sample-python-app
      spec:
      replicas: 2
      selector:
         matchLabels:
            app: sample-python-app
      template:
         metadata:
            labels:
            app: sample-python-app
         spec:
            containers:
            - name: python-app
            image: udaybiswas944/python-app-demo
            ports:
            - containerPort: 8000

   -> we can see the deployment using command kubectl get deployment
   -> create a service.yml file and apply it using command kubectl apply -f service.yml
   content of service.yml file
      apiVersion: v1
      kind: Service
      metadata:
      name: python-app
      spec:
      type: NodePort
      selector:
         app: sample-python-app
      ports:
         - port: 80
            targetPort: 8000
            nodePort: 30007

   -> we can see the service using command kubectl get svc
   -> get the ip address of the minikube using command minikube ip
   -> now we can access the pods using the ip address and port number
      ex - curl -L http://192.168.49.2:30007/demo
   
-> we can delete the deployment using command kubectl delete deployment sample-python-app
-> we can delete the service using command kubectl delete service python-app


-> labels and selectors 

- labels - are any key-value pairs that are used to identify that pod. 
   The pod gets its label through the deployment file which is like a blueprint
   for the pod before the pod is created.
   example syntax of labels in deployment file:
   "metadata": 
   {
      "labels": 
      {
         "key1" : "value1",
         "key2" : "value2"
      }
   }

- selectors - are used to select the pods based on the labels in the 
   service yaml file or directly though commands.
   example syntax of selectors in service file:
   "spec": 
   {
      "selector": 
      {
         "key1" : "value1",
         "key2" : "value2"
      }
   }

-> commmand to show the labels of the pods - "kubectl get pods --show-labels
-> command to show the pods based on the labels - "kubectl get pods -l key1=value1"

To add labels to the pods:  "kubectl label pods podname key1=value1"
To delete labels from the pods: "kubectl label pods podname key1-"

-> selector syntax: 
   They are mainly of three types:
   1. equality-based selectors
   2. set-based selectors
   3. combining selectors

   1. equality-based selectors:
      - syntax: "key1=value1"
      - example: "app=nginx"
      - command: "kubectl get pods -l app=nginx"
      - command: "kubectl get pods -l app!=nginx"
      
   2. set-based selectors:
      - syntax: "key1 in (value1,value2)"
      - example: "app in (nginx,mysql)"
      - command: "kubectl get pods -l 'app in (nginx,mysql)'"
      - command: "kubectl get pods -l 'app notin (nginx,mysql)'"

   3. combining selectors:
      here we can use logical operators like AND, OR to combine the selectors.
      - syntax: "key1=value1" AND "key2=value2"
      - example: "app=nginx" AND "tier=frontend"
      - command: "kubectl get pods -l 'app=nginx' -l 'tier=frontend'"
      - command: "kubectl get pods -l 'app=nginx,tier=frontend'"
      - command: "kubectl get pods -l 'app=nginx' OR 'tier=frontend'"

-> we can also use the labels and selectors in the deployment file.
   example syntax of labels in deployment file:
   "metadata": 
   {
      "labels": 
      {
         "key1" : "value1",
         "key2" : "value2"
      }
   }

   example syntax of selectors in service file:
   "spec": 
   {
      "selector": 
      {
         "key1" : "value1",
         "key2" : "value2"
      }
   }

-> we can also update the labels of the pods using command 
   "kubectl label pods -l Existing-key:Existing-value New-key:New-value"